[{"title":"Hello World","url":"/2023/03/28/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"keystone使用","url":"/2023/03/28/keystone%E4%BD%BF%E7%94%A8/","content":"\n\n编译x86的shellcodepy代码：\nimport keystoneshellcode = &#x27;jmp 0x15&#x27;ks = keystone.Ks(keystone.KS_ARCH_X86,keystone.KS_MODE_32)encoding,count = ks.asm(shellcode)for i in encoding:    print(hex(i))\n\n简单理解：\nKs函数，加载一个反汇编引擎\nasm函数，将一段shellcode转化为二进制\n","tags":["工具学习"]},{"title":"CS篇（一）小试牛刀","url":"/2023/07/06/CS%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80/","content":"\n\n在本地测试CS上线CS工具使用需要linux和windows系统，这里准备了一台win7虚拟机和kali虚拟机。\n网络配置：\nkali：192.168.178.129\nwin7：192.168.178.139\nCS工具分为服务端和客户端，服务端需要搭建在linux系统上，客户端在windows系统上使用。\n首先在linux上使用命令启动服务端，打开文件目录下的teamserver即可，有两个参数是必填的，第一个是服务端所用设备的IP地址，第二个参数是连接服务端用到的密码。\n\n服务端成功启动之后，就可以切换到windows系统，打开文件目录下的start.bat，之后会提示输入服务端IP地址和连接密码，输入正确即可进入控制页面。\n\n点击工具框中的耳机图标开启一个监听器，监听器用于和CS生成的beacon进行连接，这里先创建一个HTTP监听器。\n\n创建监听器后，在选项菜单中选择Attacks -&gt; Packages -&gt; Windows Executable(S) 创建样本，选择与刚创建的监听器绑定，我们就成功生成了一个远控木马了。\n\n在另一个win10系统中运行CS生成的beacon.exe，在客户端上就看到该主机上线了，测试ls命令可以成功执行。\n\n","tags":["CobaltStrike"]},{"title":"CobaltStrike生成beacon分析","url":"/2023/07/18/CobaltStrike%E7%94%9F%E6%88%90beacon%E5%88%86%E6%9E%90/","content":"\n\n使用cs生成beacon，进行分析。\nbeacon主要结构为一段shellcode和加载器。\n首先对shellcode进行调试，通过在VirtualAlloc函数下断点，定位shellcode内存\n\ndec ebppop edxcall 320007\n\n4D 5A E8 00000000\npop ebxmov edi,edxpush edxinc ebppush ebpmov ebp,espadd ebx,8150call ebx\n\n\n\npush 56A2B5F0push 4push edicall eax\n\n","tags":["CobaltStrike"]},{"title":"z3库进阶","url":"/2023/11/08/z3%E5%BA%93%E8%BF%9B%E9%98%B6/","content":"Z3库使用简单介绍z3众所周知z3库是一个优秀的求解器，可以求解给出的给定的等式。\n简单的库内函数：\n# 创建一个求解对象s = Solver()# 添加判断条件s.add(等式)# 判断是否有解s.check# 声明不同类型的未知数# int型，无法使用按位运算a = Int(&#x27;a&#x27;)a,b = Ints(&#x27;a b&#x27;)# real型a = Real()# 位向量，name表示名字，bv表示大小x = BitVec(&#x27;x&#x27;,8)x = [BitVecs(f&#x27;x[&#123;i&#125;]&#x27;,8) for i in range(8)]\n\nz3的一些特性先看一段z3代码，猜测一下输出的结果。\nfrom z3 import *s = Solver()x = Int(&#x27;k&#x27;)k = Int(&#x27;x&#x27;)a = x + 10s.add(a == 15)a = a - ks.add(a == 12)if s.check():    print(s.model())\n\n输出结果是：\n[x = 3, k = 5]\n\n从这段代码可以看出一些z3的特性，首先是z3声明未知数的命名，可以看到name其实只有在最后显示计算结果的时候才会用到，之前的算式与未知数的命名是无关的，只与存放未知数的变量名有关，当然最好保证变量名与未知数名的一致性。\n第二点，z3是可以理解等式成立的先后顺序的，这里两个判断式都是判断a与一个值是否相等，但是中间插入了运算，可以看到z3是能正确求解得。\nz3的求解同时也可以配合python中的循环与判断语句，来求解更复杂的式子。\n","tags":["工具学习"]},{"url":"/2023/07/18/CobaltStrike%E7%94%9F%E6%88%90beacon%E5%88%86%E6%9E%90.assets/fenx/","content":""},{"title":"pwn加载不同版本libc调试程序","url":"/2023/11/09/pwn%E5%8A%A0%E8%BD%BD%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AClibc%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F/","content":"获取所有版本的libc和ld文件github网站：\nhttps://github.com/matrix1001/glibc-all-in-one\n\n将项目打包下载，在目标文件夹内先执行\npython3 ./update_list\n\n会生成list文件，里面包含了可以下载的libc版本。\n我在尝试运行一道pwn题，要用到2.34版本的libc，但是运行发现2.34的源现在没了，不过是道栈溢出，更高版本一个也行。\n报错：\ntar (child): zstd：无法 exec: 没有那个文件或目录\n\n疑似是因为没有zstd\nsudo apt install zstd\n\n成功了，进入下一步。\npatchelf运用patchelf工具，可以修改程序绑定的libc和ld文件。\n关于patchelf的安装，可以直接在github上下载，用make工具安装，相关环境如果没有安装可以百度一下安装教程。\nhttps://github.com/NixOS/patchelf/releases/tag/0.12\n\n接下来以我的题目为例，题目名为chal\n首先用ldd指令查看当前用到的libc和ld：\n$ ldd ./chal./chal: /lib/x86_64-linux-gnu/libc.so.6: version `GLIBC_2.34&#x27; not found (required by ./chal)\tlinux-vdso.so.1 (0x00007ffd15def000)\tlibc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fe684267000)\t/lib64/ld-linux-x86-64.so.2 (0x00007fe684470000)\n\n可以看到libc版本不匹配，需要通过patchelf修改。\n$ patchelf --replace-needed libc.so.6 ./libc.so.6 ./chal$ patchelf --set-interpreter ./ld-linux-x86-64.so.2 ./chal\n\n上面第一条指令用来修改绑定libc，第二条用来修改ld，指令用法如下：\npatchelf --replace-needed libc.so.6 修改libc的路径 文件路径patchelf --set-interpreter 修改ld的路径 文件路径\n\n执行后可以成功运行chal文件。\n","tags":["工具使用"]},{"title":"NepCTF-九龙拉棺-复现","url":"/2023/11/27/NepCTF-%E4%B9%9D%E9%BE%99%E6%8B%89%E6%A3%BA-%E5%A4%8D%E7%8E%B0/","content":"解题步骤首先对main函数进行分析，可以看出主要的内容都在创建的线程中。线程之间通过全局变量实现同步，静态分析即可看出执行顺序。\n线程一：\n使用rc4初始化block，key为MessageBoxA，长度为0x3478，之后信号量变为3。\n线程三：\n使用base32加密block中的内容\n线程二：\n用来进行反调试的线程，原理很简单，就是定时校验代码段的完整性，在线程启动前将断点打好就可以绕过。还有查看drx7寄存器的状态来判断硬件断点。\n知道这些就没必要一个一个加密进行分析了，直接打断点看一看这个资源加密（或者该说是解密后的样子，定位到最后一个对该资源地址操作的地址，在线程六中打断点即可看到资源被解密成了一个pe文件，在线程六中作为子进程启动。\n将该pe文件dump出来即可进行分析，子进程用到了MapViewOfFile函数，实现对输入的访问，对输入的后半段进行tea加密后，与密文进行比较，返回比较结果。\n输入的其余部分在线程七中进行tea加密，两段tea差别在于key不一样，对两段tea进行解密即可得到flag。\n一些收获提升进程权限提升权限代码，要对一个任意进程给予相应的权限，要修改进程的访问令牌，首先要获得进程的访问令牌，通过以下代码可以获取访问令牌\nOpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES,&amp;hToken)\n\n之后对令牌进行检查和修改\n#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#pragma comment(lib, &quot;advapi32.lib&quot;)BOOL SetPrivilege(    HANDLE hToken,          // access token handle    LPCTSTR lpszPrivilege,  // name of privilege to enable/disable    BOOL bEnablePrivilege   // to enable or disable privilege    ) &#123;    TOKEN_PRIVILEGES tp;    LUID luid;    if ( !LookupPrivilegeValue(             NULL,            // lookup privilege on local system            lpszPrivilege,   // privilege to lookup             &amp;luid ) )        // receives LUID of privilege    &#123;        printf(&quot;LookupPrivilegeValue error: %u\\n&quot;, GetLastError() );         return FALSE;     &#125;    tp.PrivilegeCount = 1;    tp.Privileges[0].Luid = luid;    if (bEnablePrivilege)        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;    else        tp.Privileges[0].Attributes = 0;    // Enable the privilege or disable all privileges.    if ( !AdjustTokenPrivileges(           hToken,            FALSE,            &amp;tp,            sizeof(TOKEN_PRIVILEGES),            (PTOKEN_PRIVILEGES) NULL,            (PDWORD) NULL) )    &#123;           printf(&quot;AdjustTokenPrivileges error: %u\\n&quot;, GetLastError() );           return FALSE;     &#125;     if (GetLastError() == ERROR_NOT_ALL_ASSIGNED)    &#123;          printf(&quot;The token does not have the specified privilege. \\n&quot;);          return FALSE;    &#125;     return TRUE;&#125;\n\n检测硬件断点这段代码首先会用GetThreadContext来获取drx7寄存器的值，判断是否存在硬件断点，判断存在硬件断点后，试图去掉硬件断点，也就是给drx7赋值为0，如果不行就退出进程。\nint sub_4015E0()&#123;  HANDLE CurrentThread; // esi  CONTEXT Context; // [esp+4h] [ebp-2D0h] BYREF  memset(&amp;Context.Dr0, 0, 0x2C8u);  Context.ContextFlags = 65599;  CurrentThread = GetCurrentThread();  if ( !GetThreadContext(CurrentThread, &amp;Context) || !Context.Dr7 )    return 0;  Context.Dr7 = 0;  SetThreadContext(CurrentThread, &amp;Context);  Context.ContextFlags = 65599;  if ( GetThreadContext(CurrentThread, &amp;Context) )  &#123;    if ( Context.Dr7 )      ExitProcess(0xFFFFFF9D);  &#125;  return 1;&#125;\n\n","tags":["writeup"]}]