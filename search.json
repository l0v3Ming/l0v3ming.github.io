[{"title":"Hello World","url":"/2023/03/28/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"keystone使用","url":"/2023/03/28/keystone%E4%BD%BF%E7%94%A8/","content":"\n\n编译x86的shellcodepy代码：\nimport keystoneshellcode = &#x27;jmp 0x15&#x27;ks = keystone.Ks(keystone.KS_ARCH_X86,keystone.KS_MODE_32)encoding,count = ks.asm(shellcode)for i in encoding:    print(hex(i))\n\n简单理解：\nKs函数，加载一个反汇编引擎\nasm函数，将一段shellcode转化为二进制\n","tags":["工具学习"]},{"title":"CS篇（一）小试牛刀","url":"/2023/07/06/CS%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80/","content":"\n\n在本地测试CS上线CS工具使用需要linux和windows系统，这里准备了一台win7虚拟机和kali虚拟机。\n网络配置：\nkali：192.168.178.129\nwin7：192.168.178.139\nCS工具分为服务端和客户端，服务端需要搭建在linux系统上，客户端在windows系统上使用。\n首先在linux上使用命令启动服务端，打开文件目录下的teamserver即可，有两个参数是必填的，第一个是服务端所用设备的IP地址，第二个参数是连接服务端用到的密码。\n\n服务端成功启动之后，就可以切换到windows系统，打开文件目录下的start.bat，之后会提示输入服务端IP地址和连接密码，输入正确即可进入控制页面。\n\n点击工具框中的耳机图标开启一个监听器，监听器用于和CS生成的beacon进行连接，这里先创建一个HTTP监听器。\n\n创建监听器后，在选项菜单中选择Attacks -&gt; Packages -&gt; Windows Executable(S) 创建样本，选择与刚创建的监听器绑定，我们就成功生成了一个远控木马了。\n\n在另一个win10系统中运行CS生成的beacon.exe，在客户端上就看到该主机上线了，测试ls命令可以成功执行。\n\n","tags":["CobaltStrike"]},{"title":"CobaltStrike生成beacon分析","url":"/2023/07/18/CobaltStrike%E7%94%9F%E6%88%90beacon%E5%88%86%E6%9E%90/","content":"\n\n使用cs生成beacon，进行分析。\nbeacon主要结构为一段shellcode和加载器。\n首先对shellcode进行调试，通过在VirtualAlloc函数下断点，定位shellcode内存\n\ndec ebppop edxcall 320007\n\n4D 5A E8 00000000\npop ebxmov edi,edxpush edxinc ebppush ebpmov ebp,espadd ebx,8150call ebx\n\n\n\npush 56A2B5F0push 4push edicall eax\n\n","tags":["CobaltStrike"]},{"title":"z3库进阶","url":"/2023/11/08/z3%E5%BA%93%E8%BF%9B%E9%98%B6/","content":"Z3库使用简单介绍z3众所周知z3库是一个优秀的求解器，可以求解给出的给定的等式。\n简单的库内函数：\n# 创建一个求解对象s = Solver()# 添加判断条件s.add(等式)# 判断是否有解s.check# 声明不同类型的未知数# int型，无法使用按位运算a = Int(&#x27;a&#x27;)a,b = Ints(&#x27;a b&#x27;)# real型a = Real()# 位向量，name表示名字，bv表示大小x = BitVec(&#x27;x&#x27;,8)x = [BitVecs(f&#x27;x[&#123;i&#125;]&#x27;,8) for i in range(8)]\n\nz3的一些特性先看一段z3代码，猜测一下输出的结果。\nfrom z3 import *s = Solver()x = Int(&#x27;k&#x27;)k = Int(&#x27;x&#x27;)a = x + 10s.add(a == 15)a = a - ks.add(a == 12)if s.check():    print(s.model())\n\n输出结果是：\n[x = 3, k = 5]\n\n从这段代码可以看出一些z3的特性，首先是z3声明未知数的命名，可以看到name其实只有在最后显示计算结果的时候才会用到，之前的算式与未知数的命名是无关的，只与存放未知数的变量名有关，当然最好保证变量名与未知数名的一致性。\n第二点，z3是可以理解等式成立的先后顺序的，这里两个判断式都是判断a与一个值是否相等，但是中间插入了运算，可以看到z3是能正确求解得。\nz3的求解同时也可以配合python中的循环与判断语句，来求解更复杂的式子。\n","tags":["工具学习"]},{"url":"/2023/07/18/CobaltStrike%E7%94%9F%E6%88%90beacon%E5%88%86%E6%9E%90.assets/fenx/","content":""},{"title":"pwn加载不同版本libc调试程序","url":"/2023/11/09/pwn%E5%8A%A0%E8%BD%BD%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AClibc%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F/","content":"获取所有版本的libc和ld文件github网站：\nhttps://github.com/matrix1001/glibc-all-in-one\n\n将项目打包下载，在目标文件夹内先执行\npython3 ./update_list\n\n会生成list文件，里面包含了可以下载的libc版本。\n我在尝试运行一道pwn题，要用到2.34版本的libc，但是运行发现2.34的源现在没了，不过是道栈溢出，更高版本一个也行。\n报错：\ntar (child): zstd：无法 exec: 没有那个文件或目录\n\n疑似是因为没有zstd\nsudo apt install zstd\n\n成功了，进入下一步。\npatchelf运用patchelf工具，可以修改程序绑定的libc和ld文件。\n关于patchelf的安装，可以直接在github上下载，用make工具安装，相关环境如果没有安装可以百度一下安装教程。\nhttps://github.com/NixOS/patchelf/releases/tag/0.12\n\n接下来以我的题目为例，题目名为chal\n首先用ldd指令查看当前用到的libc和ld：\n$ ldd ./chal./chal: /lib/x86_64-linux-gnu/libc.so.6: version `GLIBC_2.34&#x27; not found (required by ./chal)\tlinux-vdso.so.1 (0x00007ffd15def000)\tlibc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fe684267000)\t/lib64/ld-linux-x86-64.so.2 (0x00007fe684470000)\n\n可以看到libc版本不匹配，需要通过patchelf修改。\n$ patchelf --replace-needed libc.so.6 ./libc.so.6 ./chal$ patchelf --set-interpreter ./ld-linux-x86-64.so.2 ./chal\n\n上面第一条指令用来修改绑定libc，第二条用来修改ld，指令用法如下：\npatchelf --replace-needed libc.so.6 修改libc的路径 文件路径patchelf --set-interpreter 修改ld的路径 文件路径\n\n执行后可以成功运行chal文件。\n","tags":["工具使用"]}]